# -*- coding: utf-8 -*-
"""PS1-9/6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eKc_N6ZTYcRlhTnX-vVjnXs4pzU-ylA7
"""





!pip install librosa

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

filename='/content/MANDOVI-TEST_20140313_140000.wav'

"""INSTALLING LIBRARIES"""

import IPython.display as ipd  #interesting utitlities
import librosa
import librosa.display

!dir  #not used

"""THIS WILL PLOT A PRSSURE VS TIME GRAPH"""

plt.figure(figsize=(14,5))   #figure size mentioned
data,sample_rate=librosa.load(filename)    #defining sample rate and data
librosa.display.waveplot(data,sr=sample_rate)  #using librosa library for display  ,,to ease our typing we have shown sample_rate by sr
ipd.Audio(filename)   # this is the file loading the data.

sr  #this shows the sample rate

"""PLOTTING AMPLITUDE ENVELOP(LIBRARIES ALREADY INCLUDED IN ABOVE CODE)"""

filename, sr = librosa.load(filename)   #to get sample rate

filename.shape  # this gives th total samples in the data

filename   #this shows the samples in  mono channel



# duration in seconds of 1 sample
#sample_duration = 1 / sr
#print(f"One sample lasts for {sample_duration:6f} seconds")



"""a)Visualising audio signal in the time domain




"""

plt.figure(figsize=(15, 17))  #size

plt.subplot(3, 1, 1)   #rows,column,index
librosa.display.waveplot(filename, alpha=0.5)   #here aplha gives transparency..USE OF IT ?
plt.ylim((-1, 1))   #the limit can be changed
plt.title("loaded .wav file")

"""MAGNITUDE VS FREQUENCY spectrum

> Indented block

**so we basically will be changing the form of the frequency vs magnitde curve using DIRECT FOURIER TRANSFORMATION ie from time vs power to freq vs power**

DFT analyses frame to frame
"""

import scipy as sp   #any error in np and sp means you ,inclusion of these libraries necessary
import numpy as np #library need to be loaded

# derive spectrum using FT
ft = sp.fft.fft(filename)    #here we use FT for more HUMAN ACCEPTABLE FORM
magnitude = np.absolute(ft)
frequency = np.linspace(0, sr, len(magnitude))

# plot spectrum
plt.figure(figsize=(18, 8))
plt.plot(frequency[:5000], magnitude[:5000]) # magnitude spectrum  ,the brackets provde range IS THE RANGE IN BRACKET ?
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")  #magnitude is also power ...check UNITS ??...mV
plt.show()

"""GOING TOWARD SPECTROGRAM PLOTTING"""

import os
import librosa
import librosa.display
import IPython.display as ipd
import numpy as np
import matplotlib.pyplot as plt

filename='/content/MANDOVI-TEST_20140313_140000.wav'  #librosa used

scale, sr = librosa.load(filename)

FRAME_SIZE = 2048   # these are just the parameters to be set
HOP_SIZE = 512

S_scale = librosa.stft(scale, n_fft=FRAME_SIZE, hop_length=HOP_SIZE)  # this is a function defined in library

S_scale.shape  # first dimesion gives frequency

type(S_scale[0][0])  # the output is complex

"""

```
# This is formatted as code
```

CALCULATING SPECTROGRAM"""

Y_scale = np.abs(S_scale) ** 2  # square the magnitude  we obtained using stft

Y_scale.shape

type(Y_scale[0][0])

def plot_spectrogram(Y, sr, hop_length, y_axis="linear"):  #Y is the spectogram ,we pass sample ratre ,etc
    plt.figure(figsize=(25, 10))  # we are defining a function here
    librosa.display.specshow(Y,
                             sr=sr,
                             hop_length=hop_length,
                             x_axis="time",
                             y_axis=y_axis)
    plt.colorbar(format="%+2.f")     #legend

plot_spectrogram(Y_scale, sr, HOP_SIZE)   # this is not how we actually percieve as human , hence for our analysis we will have to change it

"""LOG AMPLITUDE SPECTROGRAM"""

Y_log_scale = librosa.power_to_db(Y_scale)#we need to make the amplitude from linear to logarathmic...as to get data ..WE ARE CONVERTING Y FROM LINEAR TO LOGARTITHMIC SCALE
plot_spectrogram(Y_log_scale, sr, HOP_SIZE)  # the above line is inbuilt function

"""LOG FREQUENCY SPECTROGRAM"""

plot_spectrogram(Y_log_scale, sr, HOP_SIZE, y_axis="log") # this representation will be easy for us to interpret ,this graph is more spaced  out and easy  for us to interpret